const codeStringHook = {
  "useSidebar": "const useSidebar = () => {\r\n  const handleToggleSidebar = () => {\r\n    const sidebarContainer = document.getElementById(\"container-sidebar\") as HTMLDivElement;\r\n    const sidebar = document.getElementById(\"sidebar\") as HTMLDivElement;\r\n    const sidebarOverlay = document.getElementById(\"overlay-sidebar\") as HTMLDivElement;\r\n    const iconClose = document.getElementById(\"icon-close\") as HTMLDivElement;\r\n\r\n    const isToggle = sidebarContainer?.classList.contains(\"md-show\");\r\n\r\n    const listClassSidebarContainer = [\"md-show\", \"md-modal\", \"max-h-[100vh]\", \"md-fadein-scaleup\", \"min-w-full\"];\r\n    const listClassSidebar = [\"!w-[20rem]\", \"!h-full\", \"!static\", \"!top-0\", \"transition-all\", \"duration-500\"];\r\n    const listClassOverlay = [\"md-show\"];\r\n    const listClassIconClose = [\"!flex\", \"!static\", \"!w-full\", \"!right-0\"];\r\n\r\n    if (isToggle) {\r\n      sidebarContainer?.classList.remove(...listClassSidebarContainer);\r\n      sidebar?.classList.remove(...listClassSidebar);\r\n      sidebarOverlay?.classList.remove(...listClassOverlay);\r\n      iconClose?.classList.remove(...listClassIconClose);\r\n    } else {\r\n      sidebarContainer?.classList.add(...listClassSidebarContainer);\r\n      sidebar?.classList.add(...listClassSidebar);\r\n      sidebarOverlay?.classList.add(...listClassOverlay);\r\n      iconClose?.classList.add(...listClassIconClose);\r\n    }\r\n  };\r\n  return {\r\n    handleToggleSidebar,\r\n  };\r\n};\r\n\r\nexport default useSidebar;\r\n",
  "useAPI": "import { baseURLAPI, globalErrorMessage } from \"@lib/config/global-variable\";\r\nimport useGlobalStore from \"@store\";\r\nimport { TObject } from \"@types\";\r\nimport axios from \"axios\";\r\n\r\ninterface TParamsApiClient {\r\n    baseUrl?: string;\r\n    method?: \"get\" | \"post\" | \"put\" | \"post\";\r\n    bareerToken?: string;\r\n    endpoint: string;\r\n    payload?: TObject\r\n}\r\n\r\nconst useAPI = () => {\r\n    const { setAlertConfig, setIsLoading } = useGlobalStore()\r\n\r\n    const apiClient = async (params: TParamsApiClient): Promise<{ data: TObject | null; success: boolean; message: string; }> => {\r\n        const { baseUrl, method = \"get\", bareerToken, endpoint, payload } = params\r\n        try {\r\n\r\n            setIsLoading(true)\r\n\r\n            axios.defaults.baseURL = baseUrl || baseURLAPI\r\n            axios.defaults.headers.common['Authorization'] = bareerToken ? `Bearer ${bareerToken}` : null\r\n            axios.defaults.method = method\r\n\r\n            const response = await axios({\r\n                withCredentials: !!bareerToken,\r\n                url: endpoint,\r\n                data: payload\r\n            })\r\n\r\n            setAlertConfig({\r\n                show: true,\r\n                message: 'Successfully get data',\r\n                type: \"success\"\r\n            })\r\n\r\n            return {\r\n                success: true,\r\n                data: response.data,\r\n                message: 'Success get data'\r\n            }\r\n        } catch (error: any) {\r\n            // console.log(\"error message: \", error?.message)\r\n            // console.log(\"error messag api: \", error?.response)\r\n\r\n            setAlertConfig({\r\n                show: true,\r\n                message: globalErrorMessage,\r\n                type: \"error\"\r\n            })\r\n            return {\r\n                success: false,\r\n                data: null,\r\n                message: ''\r\n            }\r\n        } finally {\r\n            setIsLoading(false)\r\n        }\r\n\r\n    }\r\n\r\n    return {\r\n        apiClient\r\n    }\r\n}\r\n\r\nexport default useAPI",
  "useForm": "import { TEventOnChange, TForm } from \"@types\";\r\nimport { useMemo, useState } from \"react\";\r\n\r\ninterface TPropsForm<TKey extends string> {\r\n  initialForm: TForm<TKey, false>; // Adjust TObject as needed\r\n}\r\n\r\nconst useForm = <TKey extends string>({ initialForm }: TPropsForm<TKey>) => {\r\n  const defaultForm = useMemo(() => {\r\n    const form: TForm<TKey> = {} as TForm<TKey>;\r\n\r\n    Object.keys(initialForm).forEach((key) => {\r\n      const rKey = key as TKey;\r\n      form[rKey] = {\r\n        name: key,\r\n        ...initialForm[rKey],\r\n        value: initialForm[rKey]?.value,\r\n      };\r\n    });\r\n\r\n    return form;\r\n  }, [initialForm]);\r\n\r\n  const [form, setForm] = useState<TForm<TKey>>(defaultForm);\r\n\r\n  const handleOnChange = (e: TEventOnChange) => {\r\n    const name = e.target.name as TKey;\r\n    const value = e.target.value;\r\n    setForm({\r\n      ...form,\r\n      [name]: {\r\n        ...form[name],\r\n        value,\r\n      },\r\n    });\r\n  };\r\n\r\n  return {\r\n    form,\r\n    setForm,\r\n    handleOnChange,\r\n  };\r\n};\r\n\r\nexport default useForm;\r\n",
  "useFormattedInput": "import { useRef } from \"react\";\r\n\r\ninterface TProps {\r\n  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\r\n  formatPattern: string;\r\n  value: string;\r\n}\r\n\r\nconst useFormattedInput = (props: TProps) => {\r\n  const { onChange, formatPattern, value } = props;\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const formatValue = (value: string, pattern: string): string => {\r\n    const digitsOnly = String(value).replace(/\\D/g, \"\");\r\n    let formattedValue = \"\";\r\n    let patternIndex = 0;\r\n    let valueIndex = 0;\r\n\r\n    while (valueIndex < digitsOnly.length && patternIndex < pattern.length) {\r\n      if (pattern[patternIndex] === \"X\") {\r\n        formattedValue += digitsOnly[valueIndex];\r\n        valueIndex++;\r\n      } else {\r\n        formattedValue += pattern[patternIndex];\r\n      }\r\n      patternIndex++;\r\n    }\r\n\r\n    return formattedValue;\r\n  };\r\n\r\n  const handleOnChangeFormattedValue = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const { selectionStart } = e.target;\r\n    let cursorPosition = selectionStart as number;\r\n    const valueDeleted = value[cursorPosition];\r\n    const valueRaw = e.target.value;\r\n\r\n    const formattedValue = formatValue(valueRaw, formatPattern);\r\n    if (inputRef.current) {\r\n      const inputLengthDifference = formattedValue.length - e.target.value.length;\r\n      cursorPosition = (selectionStart as number) + inputLengthDifference;\r\n      if ([\",\", \"-\", \".\"]?.includes(valueDeleted)) {\r\n        cursorPosition -= 1;\r\n      }\r\n    }\r\n    e.target.value = formattedValue;\r\n    onChange(e);\r\n    setTimeout(() => {\r\n      if (inputRef.current) {\r\n        inputRef.current.selectionStart = cursorPosition;\r\n        inputRef.current.selectionEnd = cursorPosition;\r\n      }\r\n    }, 0);\r\n    return e;\r\n  };\r\n\r\n  return { inputRef, handleOnChangeFormattedValue, formatValue };\r\n};\r\n\r\nexport default useFormattedInput;\r\n",
  "useMediaQuery": "import { useEffect, useState } from 'react';\r\n\r\nconst mediaQueryConfig = {\r\n    isMinLg: '(min-width: 1024px)',\r\n    isMinMd: '(min-width: 768px)',\r\n    isMaxMd: '(max-width: 768px)',\r\n    isMinSm: '(min-width: 640px)'\r\n};\r\n\r\n\r\ntype TKeyMediaQuery = keyof typeof mediaQueryConfig\r\n\r\ntype TMediaQueryConfig = typeof mediaQueryConfig;\r\n\r\ntype TMediaQueryMatches = {\r\n    [key in keyof TMediaQueryConfig]: boolean;\r\n};\r\n\r\nconst useMediaQuery = () => {\r\n    const [matches, setMatches] = useState<TMediaQueryMatches>(() => {\r\n        const initialMatches: TMediaQueryMatches = {} as TMediaQueryMatches;\r\n        for (const key in mediaQueryConfig) {\r\n            initialMatches[key as TKeyMediaQuery] = window.matchMedia(mediaQueryConfig[key as TKeyMediaQuery]).matches;\r\n        }\r\n        return initialMatches;\r\n    });\r\n\r\n    useEffect(() => {\r\n        const mediaQueryLists: { [key in keyof TMediaQueryConfig]: MediaQueryList } = {} as {\r\n            [key in keyof TMediaQueryConfig]: MediaQueryList;\r\n        };\r\n\r\n        for (const key in mediaQueryConfig) {\r\n            mediaQueryLists[key as TKeyMediaQuery] = window.matchMedia(mediaQueryConfig[key as TKeyMediaQuery]);\r\n        }\r\n\r\n        const handleMediaQueryChange = () => {\r\n            const updatedMatches: TMediaQueryMatches = {} as TMediaQueryMatches;\r\n            for (const key in mediaQueryConfig) {\r\n                updatedMatches[key as TKeyMediaQuery] = mediaQueryLists[key as TKeyMediaQuery].matches;\r\n            }\r\n            setMatches(updatedMatches);\r\n        };\r\n\r\n        for (const key in mediaQueryLists) {\r\n            mediaQueryLists[key as TKeyMediaQuery].addEventListener('change', handleMediaQueryChange);\r\n        }\r\n\r\n        const handleResize = () => {\r\n            handleMediaQueryChange();\r\n        };\r\n\r\n        handleMediaQueryChange();\r\n        \r\n        window.addEventListener('resize', handleResize);\r\n\r\n        return () => {\r\n            for (const key in mediaQueryLists) {\r\n                mediaQueryLists[key as  TKeyMediaQuery].removeEventListener('change', handleMediaQueryChange);\r\n            }\r\n            window.removeEventListener('resize', handleResize);\r\n        };\r\n    }, []);\r\n\r\n    return matches;\r\n};\r\n\r\nexport default useMediaQuery;\r\n",
  "useMenu": "import { useMatches } from \"react-router-dom\"\r\n\r\n\r\nconst useMenu = () => {\r\n    const matches = useMatches()\r\n    const pagesMatch = matches?.filter(page => page.pathname === location.pathname)\r\n    const currentPageData: any = pagesMatch?.[pagesMatch?.length - 1]?.handle\r\n\r\n    return {\r\n        ...currentPageData\r\n    }\r\n}\r\n\r\nexport default useMenu",
  "useOnClickOutside": "import { RefObject, useEffect } from \"react\";\r\nimport { isEmptyValue } from '@/lib/utils/helper';\r\n\r\ninterface TProps<T> {\r\n    handler: () => void;\r\n    ref: RefObject<T>;\r\n    refExceptions?: RefObject<T>[];\r\n\r\n}\r\n\r\nconst useOnClickOutside = <T extends HTMLElement>(props: TProps<T>) => {\r\n    const { ref, handler, refExceptions } = props\r\n    useEffect(() => {\r\n        const handleClickOutside = (event: MouseEvent | TouchEvent) => {\r\n            if (ref.current && !ref.current.contains(event.target as Node) && (isEmptyValue(refExceptions) ? true : !refExceptions?.some(exceptionRef => {\r\n                return exceptionRef.current?.contains(event.target as Node)\r\n            }))) {\r\n                handler();\r\n            }\r\n        };\r\n        document.addEventListener(\"mousedown\", handleClickOutside);\r\n        document.addEventListener(\"touchstart\", handleClickOutside);\r\n\r\n        return () => {\r\n            document.removeEventListener(\"mousedown\", handleClickOutside);\r\n            document.removeEventListener(\"touchstart\", handleClickOutside);\r\n        };\r\n    }, [ref, handler]);\r\n};\r\n\r\nexport default useOnClickOutside;",
  "useTable": "import { TTableProps } from \"@components/ui/Table\";\r\nimport { TColumn, TSettingTable } from \"@types\";\r\nimport React, { useEffect, useState } from \"react\";\r\n\r\ninterface TProps<TData, TIncludeChecked extends boolean = false> {\r\n    initialColumn: TTableProps<TData, TIncludeChecked>[\"columns\"]\r\n    initialData?: TData[]\r\n    initialSetting: Partial<TSettingTable<TData>>\r\n    onFetchData: (params: TSettingTable<TData>) => Promise<TData[]>;\r\n\r\n}\r\n\r\nconst useTable = <TData extends object, TIncludeChecked extends boolean = false>(props: TProps<TData, TIncludeChecked> & Omit<TTableProps<TData, TIncludeChecked>,\"setting\" |\"data\" | \"columns\" | \"settings\" | \"onChange\" | \"setData\">) => {\r\n    const { initialColumn, initialData, initialSetting, onFetchData: handleFetchData, ...anotherConfigTable } = props\r\n    const [data, setData] = useState<TData[]>(initialData || [])\r\n\r\n\r\n    const [setting, setSetting] = useState<TSettingTable<TData>>({\r\n        currentPage: 1,\r\n        totalPage: 10,\r\n        itemsPerPage: 10,\r\n        ...initialSetting,\r\n    })\r\n\r\n    const columns: TColumn<TData, keyof TData>[] = React.useMemo(\r\n        () => initialColumn,\r\n        [initialColumn]\r\n    );\r\n\r\n    useEffect(() => {\r\n        onChange(setting)\r\n    }, [])\r\n\r\n    const onChange = async (params: TSettingTable<TData>) => {\r\n        const data = await handleFetchData(params)\r\n        setData(data)\r\n        params && setSetting(params)\r\n\r\n    }\r\n\r\n    return {\r\n        setting,\r\n        columns,\r\n        setData,\r\n        data,\r\n        onChange,\r\n        ...anotherConfigTable\r\n}\r\n}\r\n\r\n\r\nexport default useTable"
};

export default codeStringHook;